'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jwtDecode = require('jwt-decode');
var tslib = require('tslib');
var crypto = require('crypto');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreAuth = require('@azure/core-auth');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var jwtDecode__default = /*#__PURE__*/_interopDefaultLegacy(jwtDecode);

// Copyright (c) Microsoft Corporation.
const parseToken = (token) => {
    const { exp } = jwtDecode__default["default"](token);
    return {
        token,
        expiresOnTimestamp: exp * 1000,
    };
};

// Copyright (c) Microsoft Corporation.
const expiredToken = { token: "", expiresOnTimestamp: -10 };
const minutesToMs = (minutes) => minutes * 1000 * 60;
const defaultExpiringSoonInterval = minutesToMs(10);
const defaultRefreshAfterLifetimePercentage = 0.5;
class AutoRefreshTokenCredential {
    constructor(refreshArgs) {
        this.expiringSoonIntervalInMs = defaultExpiringSoonInterval;
        this.refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.disposed = false;
        const { tokenRefresher, token, refreshProactively } = refreshArgs;
        this.refresh = tokenRefresher;
        this.currentToken = token ? parseToken(token) : expiredToken;
        this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
        if (this.refreshProactively) {
            this.scheduleRefresh();
        }
    }
    async getToken(options) {
        if (!this.isTokenExpiringSoon(this.currentToken)) {
            return this.currentToken;
        }
        if (!this.isTokenValid(this.currentToken)) {
            const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
            await updatePromise;
        }
        return this.currentToken;
    }
    dispose() {
        this.disposed = true;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.currentToken = expiredToken;
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
    }
    async updateTokenAndReschedule(abortSignal) {
        if (this.activeTokenUpdating) {
            return this.activeTokenUpdating;
        }
        this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
        try {
            await this.activeTokenUpdating;
        }
        finally {
            this.activeTokenUpdating = null;
        }
    }
    async refreshTokenAndReschedule(abortSignal) {
        const newToken = await this.refreshToken(abortSignal);
        if (!this.isTokenValid(newToken)) {
            throw new Error("The token returned from the tokenRefresher is expired.");
        }
        this.currentToken = newToken;
        if (this.refreshProactively) {
            this.scheduleRefresh();
        }
    }
    async refreshToken(abortSignal) {
        try {
            if (!this.activeTokenFetching) {
                this.activeTokenFetching = this.refresh(abortSignal);
            }
            return parseToken(await this.activeTokenFetching);
        }
        finally {
            this.activeTokenFetching = null;
        }
    }
    scheduleRefresh() {
        if (this.disposed) {
            return;
        }
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
        const tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();
        let timespanInMs = null;
        if (this.isTokenExpiringSoon(this.currentToken)) {
            // Schedule the next refresh for when it reaches a certain percentage of the remaining lifetime.
            timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;
        }
        else {
            // Schedule the next refresh for when it gets in to the soon-to-expire window.
            timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;
        }
        this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);
    }
    isTokenValid(token) {
        return token && Date.now() < token.expiresOnTimestamp;
    }
    isTokenExpiringSoon(token) {
        return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * StaticTokenCredential
 */
class StaticTokenCredential {
    constructor(token) {
        this.token = token;
    }
    async getToken() {
        return this.token;
    }
    dispose() {
        /* intentionally empty */
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The CommunicationTokenCredential implementation with support for proactive token refresh.
 */
class AzureCommunicationTokenCredential {
    constructor(tokenOrRefreshOptions) {
        this.disposed = false;
        if (typeof tokenOrRefreshOptions === "string") {
            this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));
        }
        else {
            this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);
        }
    }
    /**
     * Gets an `AccessToken` for the user. Throws if already disposed.
     * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
     */
    async getToken(options) {
        this.throwIfDisposed();
        const token = await this.tokenCredential.getToken(options);
        this.throwIfDisposed();
        return token;
    }
    /**
     * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
     */
    dispose() {
        this.disposed = true;
        this.tokenCredential.dispose();
    }
    throwIfDisposed() {
        if (this.disposed) {
            throw new Error("User credential is disposed");
        }
    }
}

// Copyright (c) Microsoft Corporation.
const shaHash = async (content) => crypto.createHash("sha256").update(content).digest("base64");
const shaHMAC = async (secret, content) => {
    const decodedSecret = Buffer.from(secret, "base64");
    return crypto.createHmac("sha256", decodedSecret).update(content).digest("base64");
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var _a;
/**
 * A constant that indicates whether the environment the code is running is Node.JS.
 */
const isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node);

// Copyright (c) Microsoft Corporation.
/**
 * CommunicationKeyCredentialPolicy provides a means of signing requests made through
 * the SmsClient.
 */
const communicationAccessKeyCredentialPolicy = "CommunicationAccessKeyCredentialPolicy";
/**
 * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.
 * @hidden
 *
 * @param credential - The key credential.
 */
function createCommunicationAccessKeyCredentialPolicy(credential) {
    return {
        name: communicationAccessKeyCredentialPolicy,
        async sendRequest(request, next) {
            var _a;
            const verb = request.method.toUpperCase();
            const utcNow = new Date().toUTCString();
            const contentHash = await shaHash(((_a = request.body) === null || _a === void 0 ? void 0 : _a.toString()) || "");
            const dateHeader = "x-ms-date";
            const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
            const url = new URL(request.url);
            const query = url.searchParams;
            const urlPathAndQuery = query ? `${url.pathname}?${query}` : url.pathname;
            const port = url.port;
            const hostAndPort = port ? `${url.host}:${port}` : url.host;
            const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
            const signature = await shaHMAC(credential.key, stringToSign);
            if (isNode) {
                request.headers.set("Host", hostAndPort || "");
            }
            request.headers.set(dateHeader, utcNow);
            request.headers.set("x-ms-content-sha256", contentHash);
            request.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
            return next(request);
        },
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a pipeline policy to authenticate request based
 * on the credential passed in.
 * @hidden
 *
 * @param credential - The KeyCredential or TokenCredential.
 */
function createCommunicationAuthPolicy(credential) {
    if (coreAuth.isTokenCredential(credential)) {
        const policyOptions = {
            credential: credential,
            scopes: ["https://communication.azure.com//.default"],
        };
        return coreRestPipeline.bearerTokenAuthenticationPolicy(policyOptions);
    }
    else {
        return createCommunicationAccessKeyCredentialPolicy(credential);
    }
}

// Copyright (c) Microsoft Corporation.
// TODO: update when connection string format is finalized
const CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;
const tryParseConnectionString = (s) => {
    const match = s.match(CONNECTION_STRING_REGEX);
    if ((match === null || match === void 0 ? void 0 : match[1]) && match[2]) {
        return { endpoint: match[1], credential: new coreAuth.AzureKeyCredential(match[2]) };
    }
    return undefined;
};
/**
 * Returns an EndpointCredential to easily access properties of the connection string.
 * @hidden
 *
 * @param connectionString - The connection string to parse
 * @returns Object to access the endpoint and the credentials
 */
const parseConnectionString = (connectionString) => {
    const parsedConnectionString = tryParseConnectionString(connectionString);
    if (parsedConnectionString) {
        return parsedConnectionString;
    }
    else {
        throw new Error(`Invalid connection string ${connectionString}`);
    }
};

// Copyright (c) Microsoft Corporation.
const isValidEndpoint = (host) => {
    var _a;
    const url = new URL(host);
    return (!!((_a = url.protocol) === null || _a === void 0 ? void 0 : _a.match(/^http[s]?/)) &&
        url.host !== undefined &&
        url.host !== "" &&
        (url.pathname === undefined || url.pathname === "" || url.pathname === "/"));
};
const assertValidEndpoint = (host) => {
    if (!isValidEndpoint(host)) {
        throw new Error(`Invalid endpoint url ${host}`);
    }
};
/**
 * Checks whether a value is a KeyCredential.
 *
 * @param credential - The credential being checked.
 */
const isKeyCredential = (credential) => {
    const castCredential = credential;
    return (castCredential &&
        typeof castCredential.key === "string" &&
        castCredential.getToken === undefined);
};
/**
 * Parses arguments passed to a communication client.
 * @hidden
 */
const parseClientArguments = (connectionStringOrUrl, credentialOrOptions) => {
    if (isKeyCredential(credentialOrOptions) || coreAuth.isTokenCredential(credentialOrOptions)) {
        assertValidEndpoint(connectionStringOrUrl);
        return { url: connectionStringOrUrl, credential: credentialOrOptions };
    }
    else {
        const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);
        assertValidEndpoint(host);
        return { url: host, credential };
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.
 *
 * @param identifier - The assumed CommunicationUserIdentifier to be tested.
 */
const isCommunicationUserIdentifier = (identifier) => {
    return typeof identifier.communicationUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.
 *
 * @param identifier - The assumed PhoneNumberIdentifier to be tested.
 */
const isPhoneNumberIdentifier = (identifier) => {
    return typeof identifier.phoneNumber === "string";
};
/**
 * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.
 *
 * @param identifier - The assumed available to be tested.
 */
const isMicrosoftTeamsUserIdentifier = (identifier) => {
    return typeof identifier.microsoftTeamsUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements UnknownIdentifier.
 *
 * @param identifier - The assumed UnknownIdentifier to be tested.
 */
const isUnknownIdentifier = (identifier) => {
    return typeof identifier.id === "string";
};
/**
 * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.
 *
 * @param identifier - The identifier whose kind is to be inferred.
 */
const getIdentifierKind = (identifier) => {
    if (isCommunicationUserIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "communicationUser" });
    }
    if (isPhoneNumberIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "phoneNumber" });
    }
    if (isMicrosoftTeamsUserIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "microsoftTeamsUser" });
    }
    return Object.assign(Object.assign({}, identifier), { kind: "unknown" });
};

// Copyright (c) Microsoft Corporation.
const addRawIdIfExisting = (identifier, rawId) => {
    return rawId === undefined ? identifier : Object.assign(Object.assign({}, identifier), { rawId: rawId });
};
const assertNotNullOrUndefined = (obj, prop) => {
    const subObjName = Object.keys(obj)[0];
    const subObj = obj[subObjName];
    if (prop in subObj) {
        return subObj[prop];
    }
    throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);
};
const assertMaximumOneNestedModel = (identifier) => {
    const props = tslib.__rest(identifier, ["rawId"]);
    const keys = Object.keys(props);
    if (keys.length > 1) {
        throw new Error(`Only one of the properties in ${JSON.stringify(keys)} should be present.`);
    }
};
/**
 * @hidden
 * Translates a CommunicationIdentifier to its serialized format for sending a request.
 * @param identifier - The CommunicationIdentifier to be serialized.
 */
const serializeCommunicationIdentifier = (identifier) => {
    var _a, _b;
    const identifierKind = getIdentifierKind(identifier);
    switch (identifierKind.kind) {
        case "communicationUser":
            return { communicationUser: { id: identifierKind.communicationUserId } };
        case "phoneNumber":
            return addRawIdIfExisting({ phoneNumber: { value: identifierKind.phoneNumber } }, identifierKind.rawId);
        case "microsoftTeamsUser":
            return addRawIdIfExisting({
                microsoftTeamsUser: {
                    userId: identifierKind.microsoftTeamsUserId,
                    isAnonymous: (_a = identifierKind.isAnonymous) !== null && _a !== void 0 ? _a : false,
                    cloud: (_b = identifierKind.cloud) !== null && _b !== void 0 ? _b : "public",
                },
            }, identifierKind.rawId);
        case "unknown":
            return { rawId: identifierKind.id };
        default:
            throw new Error(`Can't serialize an identifier with kind ${identifierKind.kind}`);
    }
};
/**
 * @hidden
 * Translates the serialized format of a communication identifier to CommunicationIdentifier.
 * @param serializedIdentifier - The SerializedCommunicationIdentifier to be deserialized.
 */
const deserializeCommunicationIdentifier = (serializedIdentifier) => {
    assertMaximumOneNestedModel(serializedIdentifier);
    const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;
    if (communicationUser) {
        return {
            kind: "communicationUser",
            communicationUserId: assertNotNullOrUndefined({ communicationUser }, "id"),
        };
    }
    if (phoneNumber) {
        return {
            kind: "phoneNumber",
            phoneNumber: assertNotNullOrUndefined({ phoneNumber }, "value"),
            rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, "rawId"),
        };
    }
    if (microsoftTeamsUser) {
        return {
            kind: "microsoftTeamsUser",
            microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, "userId"),
            isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, "isAnonymous"),
            cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, "cloud"),
            rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, "rawId"),
        };
    }
    return {
        kind: "unknown",
        id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, "rawId"),
    };
};

exports.AzureCommunicationTokenCredential = AzureCommunicationTokenCredential;
exports.createCommunicationAccessKeyCredentialPolicy = createCommunicationAccessKeyCredentialPolicy;
exports.createCommunicationAuthPolicy = createCommunicationAuthPolicy;
exports.deserializeCommunicationIdentifier = deserializeCommunicationIdentifier;
exports.getIdentifierKind = getIdentifierKind;
exports.isCommunicationUserIdentifier = isCommunicationUserIdentifier;
exports.isKeyCredential = isKeyCredential;
exports.isMicrosoftTeamsUserIdentifier = isMicrosoftTeamsUserIdentifier;
exports.isPhoneNumberIdentifier = isPhoneNumberIdentifier;
exports.isUnknownIdentifier = isUnknownIdentifier;
exports.parseClientArguments = parseClientArguments;
exports.parseConnectionString = parseConnectionString;
exports.serializeCommunicationIdentifier = serializeCommunicationIdentifier;
//# sourceMappingURL=index.js.map
